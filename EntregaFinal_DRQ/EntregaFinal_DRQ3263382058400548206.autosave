// Código para la Visualización del Poema "Viajar" de Gabriel Gamar
// Versión completamente corregida con diagnósticos mejorados

// Variables para las imágenes de fondo
PImage fondoEscena1; // Escena 1: imagen única con zoom
PImage[][] fondosGif = new PImage[4][5]; // Escenas 2-5
int[] frameActualFondo = new int[4];
int[] totalFramesPorEscena = {5, 5, 5, 5};
int totalEscenas = 5;
int escenaActual = 0;

// Variables para el zoom de la escena 1
float zoomEscena1 = 2.5;
float zoomMinimo = 1.0;
float velocidadZoom = 0.008;

// Variables para el pájaro gif animado
PImage[] framesPajaro = new PImage[5];
int frameActualPajaro = 0;
float pajaroX, pajaroY;
float pajaroVelocidadX = 1.2, pajaroVelocidadY = 0.8;

// Variables para los símbolos interactivos
float[][] posicionesSimbolo;
int tamanoSimbolo = 35;

// Variables para el poema
String[] estrofas;

// Variables para la interacción
float radioInfluencia = 120;
float factorRepulsion = 0.3;

// Variables de control
boolean mostrarDebug = true;
boolean usarFondosFallback = false;

void setup() {
  size(800, 600);
  
  println("=== INICIANDO CARGA DE RECURSOS ===");
  
  // Cargar imagen única para escena 1
  fondoEscena1 = cargarImagenConDiagnostico("nido1.png");
  
  // Cargar fondos gif para escenas 2-5
  String[][] nombresArchivos = {
    {"tinta1.png", "tinta2.png", "tinta3.png", "tinta4.png", "tinta5.png"},
    {"bosque1.png", "bosque2.png", "bosque3.png", "bosque4.png", "bosque5.png"},
    {"montaña1.png", "montaña2.png", "montaña3.png", "montaña4.png", "montaña5.png"},
    {"pajaros1.png", "pajaros2.png", "pajaros3.png", "pajaros4.png", "pajaros5.png"}
  };
  
  for (int escena = 0; escena < 4; escena++) {
    for (int frame = 0; frame < 5; frame++) {
      fondosGif[escena][frame] = cargarImagenConDiagnostico(nombresArchivos[escena][frame]);
    }
    frameActualFondo[escena] = 0;
  }
  
  // Cargar imágenes del pájaro
  for (int i = 0; i < 5; i++) {
    framesPajaro[i] = cargarImagenConDiagnostico("pajaro" + (i+1) + ".png");
  }
  
  // Inicializar posición del pájaro
  pajaroX = width/2;
  pajaroY = height/2;
  
  // Inicializar símbolos
  posicionesSimbolo = new float[totalEscenas][2];
  for (int i = 0; i < totalEscenas; i++) {
    posicionesSimbolo[i][0] = random(80, width-80);
    posicionesSimbolo[i][1] = random(80, height-200);
  }
  
  // Cargar estrofas del poema
  inicializarEstrofas();
  
  println("=== SETUP COMPLETADO ===");
}

PImage cargarImagenConDiagnostico(String archivo) {
  println("Intentando cargar: " + archivo);
  PImage img = loadImage(archivo);
  
  if (img == null) {
    println("ERROR: " + archivo + " no se pudo cargar (archivo no encontrado)");
    return null;
  }
  
  if (img.width == 0 || img.height == 0) {
    println("ERROR: " + archivo + " tiene dimensiones 0");
    return null;
  }
  
  // Verificar contenido de la imagen
  img.loadPixels();
  int pixelesValidos = 0;
  int pixelesTotales = img.pixels.length;
  
  for (int i = 0; i < pixelesTotales; i++) {
    color pixel = img.pixels[i];
    int r = (pixel >> 16) & 0xFF;
    int g = (pixel >> 8) & 0xFF;
    int b = pixel & 0xFF;
    int a = (pixel >> 24) & 0xFF;
    
    // Contar píxeles que no sean transparentes y no sean completamente blancos
    if (a > 0 && !(r == 255 && g == 255 && b == 255)) {
      pixelesValidos++;
    }
  }
  
  float porcentajeValido = (float)pixelesValidos / pixelesTotales * 100;
  
  println("✓ " + archivo + " cargado:");
  println("  Dimensiones: " + img.width + "x" + img.height);
  println("  Píxeles válidos: " + pixelesValidos + "/" + pixelesTotales + " (" + nf(porcentajeValido, 1, 1) + "%)");
  
  if (porcentajeValido < 1) {
    println("  ADVERTENCIA: La imagen parece estar mayormente vacía");
  }
  
  return img;
}

void draw() {
  // Limpiar pantalla
  background(50);
  
  // Dibujar fondo según escena actual
  dibujarFondo();
  
  // Actualizar y dibujar pájaro
  actualizarPajaro();
  dibujarPajaro();
  
  // Dibujar símbolo interactivo
  dibujarSimbolo();
  
  // Mostrar estrofa
  mostrarEstrofa();
  
  // Mostrar información de debug si está activada
  if (mostrarDebug) {
    mostrarInformacionDebug();
  }
}

void dibujarFondo() {
  if (escenaActual == 0) {
    // Escena 1: imagen con zoom
    dibujarFondoEscena1();
  } else {
    // Escenas 2-5: gifs animados
    dibujarFondoAnimado();
  }
}

void dibujarFondoEscena1() {
  if (fondoEscena1 != null && esImagenValida(fondoEscena1)) {
    // Actualizar zoom
    if (zoomEscena1 > zoomMinimo) {
      zoomEscena1 -= velocidadZoom;
      zoomEscena1 = max(zoomEscena1, zoomMinimo);
    }
    
    // Calcular escala para llenar la pantalla
    float escalaX = (float)width / fondoEscena1.width;
    float escalaY = (float)height / fondoEscena1.height;
    float escalaBase = max(escalaX, escalaY); // Escala para llenar completamente
    
    float escalaFinal = escalaBase * zoomEscena1;
    float anchoFinal = fondoEscena1.width * escalaFinal;
    float altoFinal = fondoEscena1.height * escalaFinal;
    
    // Centrar imagen
    float x = (width - anchoFinal) / 2;
    float y = (height - altoFinal) / 2;
    
    // Dibujar imagen
    tint(255); // Asegurar que no hay tinte aplicado
    image(fondoEscena1, x, y, anchoFinal, altoFinal);
    noTint();
  } else {
    // Fondo de fallback para escena 1
    dibujarFondoFallback(0);
  }
}

void dibujarFondoAnimado() {
  // Actualizar frame cada 8 frames para animación stop-motion
  if (frameCount % 8 == 0) {
    int indiceEscena = escenaActual - 1;
    frameActualFondo[indiceEscena] = (frameActualFondo[indiceEscena] + 1) % totalFramesPorEscena[indiceEscena];
  }
  
  int indiceEscena = escenaActual - 1;
  PImage imagenActual = fondosGif[indiceEscena][frameActualFondo[indiceEscena]];
  
  if (imagenActual != null && esImagenValida(imagenActual)) {
    tint(255);
    image(imagenActual, 0, 0, width, height);
    noTint();
  } else {
    dibujarFondoFallback(escenaActual);
  }
}

boolean esImagenValida(PImage img) {
  if (img == null) return false;
  if (img.width == 0 || img.height == 0) return false;
  
  // Verificación rápida de contenido
  img.loadPixels();
  for (int i = 0; i < min(100, img.pixels.length); i += 10) {
    color pixel = img.pixels[i];
    int a = (pixel >> 24) & 0xFF;
    int r = (pixel >> 16) & 0xFF;
    int g = (pixel >> 8) & 0xFF;
    int b = pixel & 0xFF;
    
    if (a > 0 && !(r == 255 && g == 255 && b == 255)) {
      return true; // Encontramos al menos un píxel válido
    }
  }
  return false;
}

void dibujarFondoFallback(int escena) {
  switch(escena) {
    case 0: // Nido - tonos tierra
      background(101, 67, 33);
      stroke(139, 69, 19);
      strokeWeight(3);
      for (int i = 0; i < 25; i++) {
        float x1 = random(width);
        float y1 = random(height);
        float largo = random(30, 150);
        float angulo = random(TWO_PI);
        line(x1, y1, x1 + cos(angulo) * largo, y1 + sin(angulo) * largo);
      }
      fill(160, 82, 45, 100);
      ellipse(width/2, height/2, 200, 150);
      break;
      
    case 1: // Tinta - tonos púrpura y negro
      background(20, 0, 40);
      for (int i = 0; i < 12; i++) {
        fill(random(50, 150), 0, random(100, 200), random(80, 150));
        float x = random(width);
        float y = random(height);
        ellipse(x, y, random(40, 120), random(40, 120));
      }
      break;
      
    case 2: // Bosque - verdes
      background(0, 40, 0);
      fill(0, 80, 0);
      for (int i = 0; i < 20; i++) {
        float x = random(width);
        float troncoAncho = random(8, 25);
        float troncoAlto = random(100, 300);
        rect(x, height - troncoAlto, troncoAncho, troncoAlto);
        fill(0, 120, 0);
        ellipse(x + troncoAncho/2, height - troncoAlto, troncoAncho * 3, troncoAncho * 2);
        fill(0, 80, 0);
      }
      break;
      
    case 3: // Montaña - azules y grises
      background(135, 206, 235);
      fill(105, 105, 105);
      triangle(0, height, width/3, height/3, width/2, height);
      fill(119, 136, 153);
      triangle(width/4, height, width*2/3, height/4, width, height);
      fill(169, 169, 169);
      triangle(width/2, height, width*5/6, height/2, width, height);
      break;
      
    case 4: // Pájaros en el cielo - azul celeste
      background(173, 216, 230);
      fill(255, 255, 255, 200);
      for (int i = 0; i < 8; i++) {
        ellipse(random(width), random(height/3), random(30, 80), random(20, 40));
      }
      fill(0);
      for (int i = 0; i < 6; i++) {
        float x = random(width);
        float y = random(height/2);
        drawBird(x, y, random(0.8, 1.5));
      }
      break;
  }
  
  // Indicar que se está usando fallback
  fill(255, 100, 100, 200);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Usando fondo generado (imágenes no disponibles)", 5, height - 15);
}

void drawBird(float x, float y, float scale) {
  pushMatrix();
  translate(x, y);
  scale(scale);
  strokeWeight(2);
  stroke(0);
  // Alas
  arc(-8, -2, 16, 8, 0, PI);
  arc(8, -2, 16, 8, 0, PI);
  popMatrix();
}

void actualizarPajaro() {
  // Interacción con mouse
  float distancia = dist(pajaroX, pajaroY, mouseX, mouseY);
  if (distancia < radioInfluencia) {
    float direccionX = pajaroX - mouseX;
    float direccionY = pajaroY - mouseY;
    float longitud = sqrt(direccionX*direccionX + direccionY*direccionY);
    
    if (longitud > 0) {
      direccionX /= longitud;
      direccionY /= longitud;
      float fuerza = map(distancia, 0, radioInfluencia, factorRepulsion, 0);
      pajaroVelocidadX += direccionX * fuerza;
      pajaroVelocidadY += direccionY * fuerza;
    }
  }
  
  // Movimiento del pájaro
  pajaroX += pajaroVelocidadX;
  pajaroY += pajaroVelocidadY;
  
  // Rebotes suaves en los bordes
  if (pajaroX < 30) {
    pajaroX = 30;
    pajaroVelocidadX = abs(pajaroVelocidadX);
  }
  if (pajaroX > width - 30) {
    pajaroX = width - 30;
    pajaroVelocidadX = -abs(pajaroVelocidadX);
  }
  if (pajaroY < 30) {
    pajaroY = 30;
    pajaroVelocidadY = abs(pajaroVelocidadY);
  }
  if (pajaroY > height - 250) {
    pajaroY = height - 250;
    pajaroVelocidadY = -abs(pajaroVelocidadY);
  }
  
  // Limitar velocidad máxima
  float velocidadTotal = sqrt(pajaroVelocidadX*pajaroVelocidadX + pajaroVelocidadY*pajaroVelocidadY);
  if (velocidadTotal > 2.5) {
    pajaroVelocidadX = (pajaroVelocidadX / velocidadTotal) * 2.5;
    pajaroVelocidadY = (pajaroVelocidadY / velocidadTotal) * 2.5;
  }
  
  // Actualizar frame de animación del pájaro
  if (frameCount % 6 == 0) {
    frameActualPajaro = (frameActualPajaro + 1) % 5;
  }
}

void dibujarPajaro() {
  float rotacion = atan2(pajaroVelocidadY, pajaroVelocidadX);
  
  if (framesPajaro[frameActualPajaro] != null && esImagenValida(framesPajaro[frameActualPajaro])) {
    pushMatrix();
    translate(pajaroX, pajaroY);
    rotate(rotacion);
    scale(0.08);
    imageMode(CENTER);
    tint(255);
    image(framesPajaro[frameActualPajaro], 0, 0);
    noTint();
    popMatrix();
  } else {
    // Pájaro de fallback animado
    pushMatrix();
    translate(pajaroX, pajaroY);
    rotate(rotacion);
    
    // Cuerpo
    fill(255, 200, 100);
    stroke(0);
    strokeWeight(1);
    ellipse(0, 0, 20, 12);
    
    // Alas animadas
    float aleteo = sin(frameCount * 0.4) * 0.4;
    fill(200, 150, 50);
    ellipse(-6, -4 + aleteo, 12, 6);
    ellipse(-6, 4 - aleteo, 12, 6);
    
    // Pico
    fill(255, 150, 0);
    triangle(8, -2, 8, 2, 14, 0);
    
    // Ojo
    fill(0);
    ellipse(4, -2, 2, 2);
    
    popMatrix();
  }
}

void dibujarSimbolo() {
  float x = posicionesSimbolo[escenaActual][0];
  float y = posicionesSimbolo[escenaActual][1];
  
  // Efecto de hover
  float distancia = dist(mouseX, mouseY, x, y);
  float escala = distancia < tamanoSimbolo ? 1.2 : 1.0;
  
  pushMatrix();
  translate(x, y);
  scale(escala);
  
  fill(255, 215, 0);
  stroke(184, 134, 11);
  strokeWeight(2);
  
  switch(escenaActual) {
    case 0: // Casa
      rect(-12, -8, 24, 16);
      triangle(-12, -8, 12, -8, 0, -18);
      rect(-3, 0, 6, 8);
      break;
    case 1: // Copa
      fill(200, 162, 200);
      ellipse(0, -8, 16, 8);
      triangle(-8, -4, 8, -4, 0, 8);
      line(0, 8, 0, 12);
      ellipse(0, 14, 12, 4);
      break;
    case 2: // Carta
      fill(255, 255, 255);
      rect(-12, -8, 24, 16);
      fill(0);
      for (int i = 0; i < 4; i++) {
        line(-8, -4 + i*3, 8, -4 + i*3);
      }
      break;
    case 3: // Mano
      fill(255, 220, 177);
      ellipse(0, 2, 12, 16);
      for (int i = 0; i < 4; i++) {
        rect(-6 + i*3, -8, 2, 10);
      }
      break;
    case 4: // Postal
      fill(255, 255, 255);
      rect(-12, -8, 24, 16);
      fill(255, 0, 0);
      rect(4, -6, 6, 4);
      fill(0);
      line(-8, 2, -2, 2);
      line(-8, 5, 2, 5);
      break;
  }
  
  popMatrix();
}

void mostrarEstrofa() {
  // Fondo semitransparente para el texto
  fill(0, 0, 0, 180);
  rect(40, height - 220, width - 80, 180, 10);
  
  // Texto del poema
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(16);
  text(estrofas[escenaActual], width/2, height - 130);
  
  // Instrucciones
  textSize(12);
  fill(255, 255, 0);
  text("Haz clic en el símbolo dorado para cambiar de escena", width/2, height - 50);
  text("Presiona 'D' para mostrar/ocultar información de debug", width/2, height - 35);
}

void mostrarInformacionDebug() {
  fill(0, 0, 0, 150);
  rect(5, 5, 280, 120);
  
  fill(255, 255, 0);
  textAlign(LEFT, TOP);
  textSize(11);
  text("DEBUG INFO:", 10, 15);
  text("Escena: " + escenaActual + "/4", 10, 30);
  text("Frame: " + frameCount, 10, 45);
  text("Pájaro: (" + int(pajaroX) + ", " + int(pajaroY) + ")", 10, 60);
  text("Velocidad: (" + nf(pajaroVelocidadX, 1, 1) + ", " + nf(pajaroVelocidadY, 1, 1) + ")", 10, 75);
  
  if (escenaActual == 0) {
    text("Zoom: " + nf(zoomEscena1, 1, 3), 10, 90);
  } else {
    text("Frame fondo: " + frameActualFondo[escenaActual-1], 10, 90);
  }
  
  text("Mouse: (" + mouseX + ", " + mouseY + ")", 10, 105);
}

void inicializarEstrofas() {
  estrofas = new String[totalEscenas];
  
  estrofas[0] = "Viajar es marcharse de casa,\n" +
                "es dejar los amigos,\n" +
                "es intentar volar.\n" +
                "Volar conociendo otras ramas,\n" +
                "recorriendo caminos,\n" +
                "es intentar cambiar.";
  
  estrofas[1] = "Viajar es vestirse de loco,\n" +
                "es decir \"no me importa\",\n" +
                "es querer regresar.\n" +
                "Regresar valorando lo poco,\n" +
                "saboreando una copa,\n" +
                "es desear empezar.";
  
  estrofas[2] = "Viajar es sentirse poeta,\n" +
                "escribir una carta,\n" +
                "es querer abrazar.\n" +
                "Abrazar al llegar a una puerta,\n" +
                "añorando la calma,\n" +
                "es besarse y partir.";
  
  estrofas[3] = "Viajar es volverse mundano,\n" +
                "es conocer otra gente,\n" +
                "es volver a empezar.\n" +
                "Empezar extendiendo la mano,\n" +
                "aprendiendo del fuerte,\n" +
                "es sentir soledad.";
  
  estrofas[4] = "Viajar es marcharse de casa,\n" +
                "es vestirse de loco,\n" +
                "diciendo todo y nada con una postal.\n" +
                "Es dormir en otra cama,\n" +
                "sentir que el tiempo es corto,\n" +
                "viajar es regresar.";
}

void mousePressed() {
  float distancia = dist(mouseX, mouseY, 
                         posicionesSimbolo[escenaActual][0], 
                         posicionesSimbolo[escenaActual][1]);
  
  if (distancia < tamanoSimbolo) {
    escenaActual = (escenaActual + 1) % totalEscenas;
    
    // Reiniciar zoom para escena 1
    if (escenaActual == 0) {
      zoomEscena1 = 2.5;
    }
    
    // Reposicionar pájaro suavemente
    pajaroX = width/2 + random(-50, 50);
    pajaroY = height/2 + random(-50, 50);
    pajaroVelocidadX = random(-1, 1);
    pajaroVelocidadY = random(-1, 1);
  }
}

void keyPressed() {
  if (key == 'd' || key == 'D') {
    mostrarDebug = !mostrarDebug;
  }
}
//Probablemente le agregue mas venetos con otras teclas para visualizar las escenas y tal vez volver la histotia mas dinamica porque esta algo sencilla de este modo
//También probablemete le agregue alguna canción de fondo de un piano o algo de por el estilo que siga la estetica que me imagino de como  se relataria el poema
//Quiero que este sea sencillo pero interactivo y pulido porloque debo investigar sobre como hacer las transiciones fluidas ydinamicas y que no se como un cmabio de pagina en un libro digital
//También quiero saber si es posible hacer algo del estilo stop-motion para mostrar lo que quiero hacer pero se requeriran de mas imagenes con cambios mas espaciosos, por lo que quien sabe si seria mas facil hacer el dibujo de una vez en processing
